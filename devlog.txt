
06-18-2012 Design Issue:

PROBLEM:
To allow for generic reference counted data structures, all OffBrand compatible
"classes" must contain a common struct or incomplete type as the first member of
the data object for that class (the private struct in the incomplete type
implementation). Ideally this common element would be a statically allocated
incomplete type, which cannot be achieved directly.

PROPOSED SOLUTION(s):
A: Implement this base element as a struct type only. This allows for easy
   static allocation, but sacrifices data encapsulation entirely. Trades off
   data protection for ease of implementaion and use.

B: Implement this base element as an incomplete type only. This allows for
   complete data encapsulation, preventing direct manipulation of reference
   counts. Adds a large layer of complexity; the generic data type would now
   be a pointer to a pointer (the class must be dereferenced to allow access
   to the first data member of the class, a pointer to the base element).
   Complete encapsulation provided, but too much complexity added.

C: A hybrid of A&B. The base element is a struct (statically allocated) that
   contains a single pointer to an incomplete type encapsulating the reference
   counting information. Users could interact with this base element as they
   would with the base element in A, while being prevented from altering key
   data directly as in B. There is some added complexity that is added behind
   the scenes, and a small amount of data is left bare to the user (the pointer
   to the encapsulating incomplete type that is contained within the struct).

PROGRESS/DECISION:
Solution C chosen for initial implementation. Will complete in following days.
  (06-18-2012)

COMPLETED ACTION:
Not yet complete.

--------------------------------------------------------------------------------


