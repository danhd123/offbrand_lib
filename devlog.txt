
06-18-2012 Design Issue:

  HOW TO IMPLEMENT GENERIC TYPE

PROBLEM:
To allow for generic reference counted data structures, all OffBrand compatible
"classes" must contain a common struct or incomplete type as the first member of
the data object for that class (the private struct in the incomplete type
implementation). Ideally this common element would be a statically allocated
incomplete type, which cannot be achieved directly.

PROPOSED SOLUTION(s):
A: Implement this base element as a struct type only. This allows for easy
   static allocation, but sacrifices data encapsulation entirely. Trades off
   data protection for ease of implementaion and use.

B: Implement this base element as an incomplete type only. This allows for
   complete data encapsulation, preventing direct manipulation of reference
   counts. Adds a large layer of complexity; the generic data type would now
   be a pointer to a pointer (the class must be dereferenced to allow access
   to the first data member of the class, a pointer to the base element).
   Complete encapsulation provided, but too much complexity added.

C: A hybrid of A&B. The base element is a struct (statically allocated) that
   contains a single pointer to an incomplete type encapsulating the reference
   counting information. Users could interact with this base element as they
   would with the base element in A, while being prevented from altering key
   data directly as in B. There is some added complexity that is added behind
   the scenes, and a small amount of data is left bare to the user (the pointer
   to the encapsulating incomplete type that is contained within the struct).

D: Similar to C, but instead of an enclosing struct a typedef is used to combat
   the "pointer to pointer" complexity. Besided that the same idea, an
   incomplete type is hidden from the user by typedefing a pointer to an
   instance of the incomplete type to a type that appears not to be a pointer.
   UPDATE: Typedef the type, but do not use it in the incomplete type code,
   instead use it as the generic reference only.

PROGRESS/DECISION:
Solution C chosen for initial implementation. Will complete in following days.
(06-18-2012)

Updated with new proposed solution, D. (06-19-2012)

Both solutions C and D aren't great. C takes extra memory (space for a pointer
must be allocated in addition to the actual reference data), and the D syntax
clumsy. A small two or three letter type name for the generic type would likely
help with the syntax, to make the type appear more "native". itm elm pt mech ref
any ne (06-19-2012)

Chose obj as generic type name. Pointers to compatible classes can be cast to
and from a pointer to an obj instance. A version of solution D (06-19-2012)

STATUS:
Completed.

--------------------------------------------------------------------------------


06-19-2012 Design Speculation:

  CLASS REGISTRY

All compatible classes have a dealloc function predefined in created source
files that takes the name "dealloc[CLASSNAME]". This function takes an obj *
as an argument, so that it can be called by the reference counting mechanism. It
might be useful to dynamically build a "class register" that keeps track of what
types are being used in the current program, allow for dynamic class checking in
program, and to prevent class methods from being called on wrong classes.

Likely a first step down the treacherous road to writing a complete OOP library
for C.

At this date the only conflict with methods would be in dealloc. This is managed
entirely by template code generated by the class creation script, and so that
specific instance of error does not merit implementation on its own.

STATUS:
Theoretical. May not be needed or even desired.

--------------------------------------------------------------------------------
