
06-18-2012 Design Issue:

  HOW TO IMPLEMENT GENERIC TYPE

PROBLEM:
To allow for generic reference counted data structures, all OffBrand compatible
"classes" must contain a common struct or incomplete type as the first member of
the data object for that class (the private struct in the incomplete type
implementation). Ideally this common element would be a statically allocated
incomplete type, which cannot be achieved directly.

PROPOSED SOLUTION(s):
A: Implement this base element as a struct type only. This allows for easy
   static allocation, but sacrifices data encapsulation entirely. Trades off
   data protection for ease of implementaion and use.

B: Implement this base element as an incomplete type only. This allows for
   complete data encapsulation, preventing direct manipulation of reference
   counts. Adds a large layer of complexity; the generic data type would now
   be a pointer to a pointer (the class must be dereferenced to allow access
   to the first data member of the class, a pointer to the base element).
   Complete encapsulation provided, but too much complexity added.

C: A hybrid of A&B. The base element is a struct (statically allocated) that
   contains a single pointer to an incomplete type encapsulating the reference
   counting information. Users could interact with this base element as they
   would with the base element in A, while being prevented from altering key
   data directly as in B. There is some added complexity that is added behind
   the scenes, and a small amount of data is left bare to the user (the pointer
   to the encapsulating incomplete type that is contained within the struct).

D: Similar to C, but instead of an enclosing struct a typedef is used to combat
   the "pointer to pointer" complexity. Besided that the same idea, an
   incomplete type is hidden from the user by typedefing a pointer to an
   instance of the incomplete type to a type that appears not to be a pointer.
   UPDATE: Typedef the type, but do not use it in the incomplete type code,
   instead use it as the generic reference only.

PROGRESS/DECISION:
Solution C chosen for initial implementation. Will complete in following days.
(06-18-2012)

Updated with new proposed solution, D. (06-19-2012)

Both solutions C and D aren't great. C takes extra memory (space for a pointer
must be allocated in addition to the actual reference data), and the D syntax
clumsy. A small two or three letter type name for the generic type would likely
help with the syntax, to make the type appear more "native". itm elm pt mech ref
any ne (06-19-2012)

Chose obj as generic type name. Pointers to compatible classes can be cast to
and from a pointer to an obj instance. A version of solution D (06-19-2012)

STATUS:
Completed.

--------------------------------------------------------------------------------


06-19-2012 Design Speculation:

  CLASS REGISTRY

All compatible classes have a dealloc function predefined in created source
files that takes the name "dealloc[CLASSNAME]". This function takes an obj *
as an argument, so that it can be called by the reference counting mechanism. It
might be useful to dynamically build a "class register" that keeps track of what
types are being used in the current program, allow for dynamic class checking in
program, and to prevent class methods from being called on wrong classes.

Likely a first step down the treacherous road to writing a complete OOP library
for C.

At this date the only conflict with methods would be in dealloc. This is managed
entirely by template code generated by the class creation script, and so that
specific instance of error does not merit implementation on its own.

UPDATE (06-20-2012):
Simple solution implemented that check so see if two obj have the same dealloc
function, if so said to be equal. Depends on each class having one unique
dealloc function, which is not a terrible assumption to make.

STATUS:
Registry still theoretical, basic protection scheme based on dealloc function
comparison implemented.

--------------------------------------------------------------------------------

06-29-2012 Design Issue:

  LOCKING MECHANISM

All Offbrand classes require a locking mechanism to guarantee threadsafety. To
ensure a uniform interface the locking mechanism will be uniform to all Offbrand
classes (and it helps to remove some of the threadsafe procedures from user
maintenance). This mechanism should retain the object on a successful lock, and
release it before a successful unlock.

DESIGN SPECS:
Two different locking modes are desired: READ-ONLY and WRITE-ONLY. All methods
that access and obj as a const qualify for the READ-ONLY, which only locks the
data for long enough to increment an internal counter that monitors the number
of threads currently performing read only operations (there is no Offbrand
determined limit). The WRITE-ONLY lock completely locks the data so that only a
single thread may alter any of it. As soon as a thread initiates a WRITE-ONLY
lock on an obj no more threads may qualify for a READ-ONLY lock until the WRITE
has completed. Threads already reading finish their normal usage with the data
before a write occurs.

SOLUTIONS:
A)
A single queue-like data structure would be ideal for the locking mechanism,
lock requests would be stored in the queue and be processed in order of
appearance. An additional mutex or two would be needed to protect the locking
mechanism data (mutex 1) and the actual object data (mutex 2). All locks would
interact with mutex 1 to alter locking mechanism data (add and remove from
queue), but only WRITE-ONLY locks would interact with mutex 2.

PROGRESS
Read more about locking/threads in the Linux Programming Interface to determine
what structures are available and how to best meet design specs. Perhaps look
into select() system call to notify when lock status changes.

STATUS:
In planning, but should be implemented soon after the OBVector class is
completed and will need to have a thread safe implementation written.


