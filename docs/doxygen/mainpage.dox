/**
 * @mainpage 
 *
 * @section Introduction Introduction
 * offbrand is a collection of reference counted generic data structures written
 * in C for C. The library is intended to relieve the need to reimplement 
 * common data structures for the 1000th time, letting programmers focus on
 * interesting app specific code. 
 * <br><br><br>
 *
 * @section Requirements Requirements
 *
 * offbrand requires the GNU toolchain, namely:
 *
 * - GCC
 * - make
 * - glibc
 *
 * Any Linux distro or OS X with developer tools installed should be able to 
 * build the library with no issue. At this time Windows is not supported. 
 * If you would like to build the documentation for the project on your local 
 * machine then the Doxygen package is also required.
 *
 * <b>Knowledge Base: </b>
 * While the library is not terribly complex to use or understand, you should
 * be comfortable with incomplete types, typecasting, and reference counted 
 * memory management to get the most out of offbrand.
 *
 * <br><br><br>
 * 
 *
 * @section Installation Installation
 *
 * To build the library on your machine, clone the git repository and run make:
 * @code
 * $ git clone https://github.com/theck01/offbrand_lib.git
 * $ cd offbrand_lib
 * $ make test
 * @endcode
 *
 * Include desired class header files from the include/ subdirectory and link 
 * with needed object files found in the bin/class/ subdirectory when compiling
 * to integrate offbrand into your app.
 * <br><br><br>
 * 
 *
 * @section Overview Overview
 *
 * <i>NOTE</i>: The phrase "class" is used in the documentation to refer to a C 
 * style approximation of a class built from an incomplete type, rather than a 
 * true class in a language like Java or Obj-C.
 *
 * offbrand is based on a section of the C standard that dictates
 * that all structs be memory alligned. This enables a struct A, which has 
 * struct B as it's first element, to be typecast to struct B without data 
 * corruption. A contrived example of struct allignment in action:
 *
 * @code {.c}
 * struct B {
 *   int i;
 * };
 *
 * struct A {
 *   struct B element_b;
 *   int j;
 * };
 *
 * struct A *thing_a = malloc(sizeof(struct A)); 
 * thing_a->element_b.i = 10;
 *
 * // A perfectly valid cast. You loose some information but now struct A can be
 * // considered to be struct B if the need arises
 * struct B *thing_b = (struct B *)thing_a;
 *
 * // thing_b->i evaluates to 10
 * thing_b->i; 
 * @endcode
 *
 * In offbrand struct A is any of the offbrand classes and struct B is a 
 * special structure, "obj".
 *
 * An obj ("object") encapsulates data common to all classes: a reference 
 * count, pointers to class specific versions of common functions, and a class
 * name. obj is the generic type of the library, and casts from class pointers 
 * to obj pointers and back is common theme within offbrand code.
 *
 * A standard library exists that operates exclusively on obj pointers. This
 * basis allows any class instances to be compared, hashed, retained, released,
 * etc. These functions call the class specific versions of each function, if 
 * they exist, hiding large numbers of class specific functions behind a small 
 * suite of common functions.
 * <br><br><br>
 * 
 *
 * @section FileStructure File Structure
 * 
 * An offbrand compatible class (or builtin class) is split across 5 different
 * files:
 *
 * @subsection DocumentationFile Documentation File
 * An optional file that serves to provide doxygen documentation for the general
 * functionallity of the class. These files will be found in the docs/doxygen/ 
 * subdirectory of the library for builtin classes.
 * 
 * @subsection PublicHeader Public Header
 * Contains all functions operating on the class that are publicly accessable 
 * to call anywhere in any program. These files will be found in the include/ 
 * subdirectory of the library for builtin classes.
 *
 * @subsection PrivateHeader Private Header
 * Containing all functions operating on the class that should not be called
 * directly by other programs, in most circumstances, and the definitions of all
 * data encapsulated by the class. Builtin private headers can be found in the 
 * include/private/ subdirectory.
 * 
 * @subsection SourceFile Source File
 * Contains the implementation of all functions operating on the class, public 
 * and private. Source files for builtin classes can be be found in the 
 * src/classes/ subdirectory.
 *
 * @subsection UnitTestFile Unit Test File
 * An optional file, contains unit tests used to verify proper functionallity of
 * the class. Test files can be found in the src/tests/ subdirectory.
 * <br><br>
 *
 * The mkobc bash script, included in the scripts/ subdirectory, generates these
 * five files with compatiblilty boilerplate. The documentation and test files 
 * can be discarded, but the two headers and source file are essential for any
 * offbrand class compatible class. Comments included in the generated files 
 * explain why boilerplate code is included and what should and should not be
 * altered.
 * <br><br><br>
 * 
 *
 * @section Documentation Documentation
 *
 * The API references for classes can be found at this location, under Modules.
 * The documentation for each class is broken down by file. The public header
 * documentation outlines the entire public API for each class, and should have
 * all of the information required to use offbrand with standard applications.
 * Any apps that will extend or modify the library builtins may benefit from
 * the private header documentation, where the structure of the classes data and
 * private functions are documented.
 *
 * This Doxygen documentation can be built locally if the system has the doxygen
 * package installed. From the base project directory:
 * @code 
 * $ cd docs
 * $ doxygen doxygen.conf
 * @endcode
 *
 * After a successful build, documentation can be accessed in the docs/html/ 
 * subdirectory
 * <br><br><br>
 * 
 *
 * @section Examples Examples
 *
 * Example applications can be found in the app/ subdirectory. These
 * applications serve two purposes, proofs of that the library works as expected
 * and examples of how the offbrand library can be used within an application.
 * <br><br><br>
 * 
 *
 * @section Contributing Contributing
 *
 * Clone, fork, submit issues and pull requests on github:
 * https://github.com/theck01/offbrand_lib
 * <br><br><br>
 *
 */
